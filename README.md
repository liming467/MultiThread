# MultiThread
A demo to present  two kinds of multi-thread methods

# 进程

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是线程的容器。

# 线程

通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。

# 为什么要使用多线程？

一个简单的GUI程序，为了有更好的交互性，通常用一个任务支持界面交互，另一个任务支持后台运算。由此就演化出了利用分配给同一个进程的资源，尽量实现多个任务的方法。这也就引入了线程的概念。同一个进程内部的多个线程，共享的是同一个进程的所有资源。比如，与每个进程独有自己的内存空间不同，同属一个进程的多个线程共享该进程的内存空间。例如在进程地址空间中有一个全局变量globalVar，若A线程将其赋值为1，则另一线程B可以看到该变量值为1。两个线程看到的全局变量globalVar是同一个变量。通过线程可以支持同一个应用程序内部的并发，免去了进程频繁切换的开销，另外并发任务间通信也更简单。


每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。比如图片刷新等都在主线程，如果线程陷入到一个无用的循环，会导致主线程无法执行其他的东西、无法做其他的任务，此时图片刷新、ui界面等都不会刷新，会出现卡死的现象。

1、为了更好的利用CPU资源，如果只有一个线程，则第二个任务必须等待第一个任务结束后才能进行。如果使用多线程，则在主线程执行任务的同时，还可以执行其他任务，不需要等待。

2、进程之间不能共享数据，线程可以。

3、系统创建进程需要为该进程重新分配系统资源，创建线程代价比较小。

# 这里简单地演示如何利用qt实现多线程。

# 多线程方法

# 1、重写QThread继承类的run()函数

自己写一个类继承QThread，并重写其run()函数。而对于使用Qthread创建的进程而言，run()函数则是新线程的入口，run()函数退出，意味着线程的终止。
注意这种方法需要使用start()启动子线程。

# 2、使用moveToThread()函数将QObject继承类放到一个新线程

如果不想每执行一种任务就自定义一个新线程，那么可以自定义用于完成任务的类，并让它们继承自QObject。
使用的时候利用然后使用moveToThread()将自定义类移动到新线程，之后用start()启动子线程。使用耗时操作时需要利用信号槽函数触发自定义类的耗时操作。

![](https://github.com/liming467/MultiThread/blob/master/overall.png)

这里有三种例子作为示范，均为在一个while循环中对变量不断执行加1的操作。
# （1）不用多线程执行多任务的直观效果
选择上图comboBox中的MainWindow，然后点击start按钮，主线程将会在while循环中执行加1的操作。由于主线程现在在不断执行+1操作，导致不能进行其他操作，比如刷新。此时拖动不了ui界面，处于“卡死”的状态。这里例子是为了如果不用多线程会有什么效果，很直观。
为了能够继续执行后续操作，这里设置了一个+1的时间限制：10s。10s之后，主线程会自动跳出while循环，恢复正常。

# (2)重写run()函数
选择Inherit from QThread，然后点击start按钮，将会看到qCreator的输出栏一直在执行加1操作，而且操作是在一个新的线程。此时拖动ui界面，你会发现对界面拖动无影响，说明在+1操作在子线程，没有阻塞主线程。
如果想停止+1操作，点击Finish按钮即可。

# (3)使用moveToThread()函数
同（2）一样，只不过使用了另一个qt多线程方法。






